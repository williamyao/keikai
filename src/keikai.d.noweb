@
\section{Introduction}

My university has an online gradebook, which sports among its most useful
features, missing grades, inaccurate grades, and confusing interfaces.
After being told I had a grade of 3,627\% in AI, I figured it was time to
write a half-decent gradebook of my own.

\textbf{Keikai} aims to be an extremely minimal gradebook program, as well
as a demonstration of literate programming. To that end, it uses 
\texttt{ncurses} to run fast and focus on its core functionality.

\section{Implementation}

\subsection{Required software}

For running a built application, the only thing needed is a working
installation of \texttt{libncurses}. Building is a little more complicated,
and requires the following:

\begin{itemize}
\item \texttt{libncurses}, for obvious reasons.
\item \texttt{dmd}, or another compiler for the D language. Ensure that it's
    for D 2.0.
\item \texttt{noweb}, a program for working with literate source code
\item GNU \texttt{make}; alternatively, I hope you enjoy managing
    includes and linking yourself.
\end{itemize}

\subsection{About the source}

Further sections include discussion of the source code of Keikai,
hopefully organized in order to aid understanding of the structure of
the program. Code sections may include directives such as 
$\langle$\textit{name}$\rangle$,
which indicate that another section of code with the given \textit{name}
is inserted there.

\subsection{Data representation}

First things first; as Keikai is a program about managing and viewing
grades, naturally the first thing should be to decide on the representation
of said grades.

The view I take of grades is a hierarchical one: grades belong to
categories, and categories belong to different classes. A gradebook
consists of many classes. One might ask, ``Don't grades naturally belong
to classes?'' While certainly a valid way to look at grades, adding an
intermediate container, categories, makes it easier to deal with
grade \emph{weighting}, where certain grades are worth more than others,
even with the same mark or point value. For example, the final grade
may comprise quiz grades more heavily than homeworks.

This hiearchichal view is recursive; the quantity we care about, the
percentile grade of a class, is also a useful quantity when thinking
about individual categories, or individual grades. As such, we can
think of these three; classes, categories, and grades; as similar types
with a common interface. To avoid confusing it with grade objects,
we can call it \texttt{score}. Defining a common interface like this
will aid with analysis; someone using Keikai can now look at grades
for a single class, or drill down and look more deeply at individual
categories or grades.

<<grade-data-structures>>=
interface Scorable {
    public @safe double score();
}

class Grade : Scorable {
public:
    double points;
    double maxPoints;
    string description;

    @safe override double score()
    {
        return (points * 100) / maxPoints;
    }

    @safe this(double points, double maxPoints, string description = "")
    {
        this.points = points;
        this.maxPoints = maxPoints;
        this.description = description;
    }

    invariant
    {
        assert(maxPoints > 0);
    }
}

interface GradeContainer {
public:
    @safe bool canSelect(int index);
    @safe GradeContainer select(int index);
    void promptDel(WINDOW* win, int index);
    void promptAdd(WINDOW* win, int index);
    void promptEdit(WINDOW* win, int index);
    @safe @property GradeContainer parent();
    @safe @property GradeContainer parent(GradeContainer);
}

class Category : Scorable, GradeContainer {
public:
    double weight;
    Grade[] grades;
    string description;

    @safe override double score()
    {
        if(grades.length == 0) return 100;
        else {
            double points = sum(map!(a => a.points)(grades), 0.0);
            double maxPoints = sum(map!(a => a.maxPoints)(grades), 0.0);

            return (points * 100) / maxPoints;
        }
    }

    void addGrade(Grade grade)
    {
        grades ~= grade;
    }

    @safe this(double weight, string description = "")
    {
        this.weight = weight;
        this.description = description;
    }

    @safe @property GradeContainer parent() 
    {
        return _parent;
    }

    @safe @property GradeContainer parent(GradeContainer p)
    {
        return (_parent = p);
    }

    @safe GradeContainer select(int index)
    {
        throw new Exception("This should never be called.");
    }

    @safe bool canSelect(int index) 
    {
        return false;
    }

    void promptDel(WINDOW* win, int index)
    in {
        assert(index < grades.length);
    }
    body {
        werase(win);
        mvwprintw(win, 0, 1, "Are you sure you want to delete this grade? (y/n)");
        wrefresh(win);
        
        int c;

        while(true) {
            c = wgetch(win);

            switch(c) {
            case 'y', 'Y':
                grades = grades[0..index] ~ grades[index + 1..$];
            case 'n', 'N':
                return;
            default:
                break;
            }
        }
    }

    void promptAdd(WINDOW* win, int index)
    {
        werase(win);
        mvwprintw(win, 0, 1, "Enter a description for this grade: ");
        wrefresh(win);

        string description = wgetstring(win);

        double max = wgetdouble(win);

        while(true) {
            try {
                werase(win);
                mvwprintw(win, 0, 1, "Enter maximum points: ");
                wrefresh(win);

                max = wgetdouble(win);
                break;
            } catch(ConvException e) {
                werase(win);
                mvwprintw(win, 0, 1, "That doesn't seem to be a number.");
                wrefresh(win);
            }
        }

        werase(win);
        mvwprintw(win, 0, 1, "Enter points: ");
        wrefresh(win);

        double points = wgetdouble(win);

        grades ~= new Grade(points, max, description);
    }
        
    void promptEdit(WINDOW* win, int index)
    in {
        assert(index < grades.length);
    }
    body {}
private:
    GradeContainer _parent;
}

@
We cannot simply add together the scores of all the grades in the
category, since they may have different max points, and thus differing
weighting on the score of the category as a whole.

\texttt{score} for \texttt{Category} does not use \texttt{weight}, since
we only want to return the percent score for \emph{this} category,
which has nothing to do with how it would be eventually weighted to
determine the total grade for a class.

Note that if a category has no grades, the category's score is defined to
be 100, for full marks. The other choice would be to define the empty
score as 0; however, to me it makes more sense for the grade for a class
to start at 100 and (usually) decrease as the course goes on, rather than
having a rapid jump up once some grades are actually entered. This design
decision will extend to courses as well.

<<grade-data-structures>>=
class Course : Scorable {
public:
    Category[] categories;    
    string description;

    @safe override double score()
    {
        if(categories.length == 0) return 100;
        else return sum(map!(x => x.score * x.weight)(categories), 0.0);
    }

    @safe double totalWeight()
    {
        return sum(map!(x => x.weight)(categories), 0.0);
    }

    void addCategory(Category category) {
        categories ~= category;
    }

    @safe this(string description = "")
    {
        this.description = description;
    }
}

class Gradebook {
public:
    Course[] courses;

    void addCourse(Course course) {
        courses ~= course;
    }
}

@
Note the function \texttt{totalWeight}; the \texttt{Course} structure
does not \emph{enforce} that the weights for all categories add up to
1, and indeed, doing so would be impossible, unless we also mandated
that the user enter all the categories before allowing them to create
a course. Additionally, the decision of what to do when weights don't
add up seems as though it should be handled by code slightly higher
level than our basic data structures. As such, we provide enough
functionality for higher-level code to easily verify that the weights
add up to some predetermined amount, but make no judgment about it
just yet.

<<user-io>>=
string wgetstring(WINDOW* w)
{
    auto input = "";
    int c;
    
    echo();
    curs_set(1);

    while(true) {
        c = wgetch(w);

        switch(c) {
        case '\n', '\r', EOF:
            goto finish;
        default:
            input ~= c;
        }
    }

finish:
    noecho();
    curs_set(0);
    return input;
}

double wgetdouble(WINDOW* w)
{
    return to!double(wgetstring(w));
}

@
\subsection{Putting it all together}

With all the necessary components now defined, it's time to set up the main
logic of our program.

<<mainloop>>=
int input;

mvprintw(4, 2, "You pressed: ");

while(true) {
    refresh();

    input = getch();
    mvprintw(4, 15, "0x%04X", input);
}

@
Our program requires a bit of \texttt{ncurses} initialization. We choose to
use \texttt{noecho}, since we don't want user selections to echo onto the
terminal, unless we're taking in string input, like asking for descriptions
for classes or entering in numbers. We use \texttt{cbreak}, which makes all
input available to us immediately, without buffering on newlines; the choice
of \texttt{cbreak} over \texttt{raw} is because we Keikai is a fairly 
lightweight program, so we want the default handling for interrupt keys
like \texttt{\^{}Z} and \texttt{\^{}C}, instead of intercepting them ourselves. 
Using \texttt{keypad} gives us access to inputs like the arrow
and function keys as well. Finally, \texttt{curs_set} allows us to change
how the terminal cursor is displayed; in this case, we hide it, since it's
not useful to us until we get text input from the user.

<<main>>=
<<skeleton>>

int main(string[] args)
{
    initscr();
    noecho();
    cbreak();
    keypad(stdscr, true);
    curs_set(0);

    refresh();

    void* opts = null;

    WINDOW* headerWin = newwin(1, COLS, 0, 0);
    mvwchgat(headerWin, 0, 0, -1, A_REVERSE, cast(short) 0, opts);
    wattron(headerWin, A_REVERSE);
    mvwprintw(headerWin, 0, cast(int) (COLS - header.length) / 2, "%s", header.toStringz);
    wrefresh(headerWin);

    WINDOW* footerWin = newwin(1, COLS, LINES - 1, 0);
    mvwprintw(footerWin, 0, 0, "[a]dd, [e]dit, [d]elete, [q]uit".toStringz);
    mvwchgat(footerWin, 0, 0, -1, A_REVERSE, cast(short) 0, opts);
    wrefresh(footerWin);

    getch();

    delwin(headerWin);
    endwin();

    return 0;
}

@
We also need to initialize some global variables that are used by all of our
utility functions.

<<globals>>=
WINDOW* currscr;
string header = "Keikai 0.0.1";

@
\subsection{Includes}

Library functions have to come from \emph{somewhere}, after all.

<<includes>>=
import deimos.ncurses.curses;
import std.algorithm.iteration : map, sum;
import std.algorithm.comparison : max, min;
import std.conv : to, ConvException;
import std.string : toStringz;
import std.stdio : EOF;

import std.math : abs;
import std.exception : assertThrown;
import core.exception : AssertError;

@
\texttt{deimos.ncurses.curses} gives us a D wrapper for the 
\texttt{ncurses} library which acts exactly like the C one (minus
some bugs.) \texttt{std.algorithm.iteration} gives us functional
constructs like \texttt{map} and \texttt{sum} for calculating grades.
\texttt{std.conv} gives us the ability to convert strings to integers;
functionality with hopefully obvious utility. \texttt{std.string} provides
\texttt{toStringz}, which converts immutable D strings to null-terminated
C strings, for interfacing with C functions.

\texttt{std.math}, \texttt{std.exception}, and \texttt{AssertError}
give us asserts for writing unit tests.

@
Combining the includes with all of our framework gives us a driverless
``skeleton'' that we can now combine with either unit tests or a main
function to (finally!) produce something usable and executable.

<<skeleton>>=
<<includes>>
<<grade-data-structures>>
<<user-io>>

<<globals>>

@
\section{Unit tests}

\textbf{Keikai} has a full suite of unit tests; passing the \texttt{-unittest}
flag to \texttt{dmd} will compile a version of the executable that will
execute the tests, and report failures. Keikai conveniently provides
\texttt{make test} in order to compile these tests and run them. I
encourage you to run them prior to using Keikai to ensure that your
installation is working properly.

The source code for the unit tests follows, and will be interspersed
with commentary to explain what is being tested and why.

Firstly, since we're testing floating-point values, we'll need a way
to compare them that doesn't rely on exact equality.

<<unittests>>=
unittest {
    bool floatCmp(double f1, double f2, double tolerance)
    {
        return abs(f1 - f2) <= tolerance;
    }

@
First, let's make sure that our score calculations are actually working
the way we want.

<<unittests>>=
    assertThrown!AssertError(new Grade(50, 0));
    assertThrown!AssertError(new Grade(0, -5));

    assert(new Grade(40, 50));
    assert(new Grade(-5, 50));

@
Grades with a maximum score of 0 are obviously a no-go, since they 
both make no sense and would cause division by zero errors. Negative
values for maximum points are similarly nonsensical, even if they
don't cause division errors.

On the other hand, a negative or 0 value for the amount of points
is totally sensical, since that would simply not add points, or subtract
points, from the containing category, so we make sure that instantiating
a normal grade, or a grade with negative points, works just fine.

<<unittests>>=
    auto g1 = new Grade(50, 100);
    assert(floatCmp(g1.score, 50, 0.05));

    auto g2 = new Grade(40, 50);
    assert(floatCmp(g2.score, 80, 0.05));

    auto c1 = new Category(0.25);
    assert(floatCmp(c1.score, 100, 0.05));

@
Important to note is that categories that do not yet have grades
should return a score of 100. This is design decision, as noted when
designing the representation of the Grade objects et al.

<<unittests>>=
    c1.addGrade(new Grade(50, 50));
    c1.addGrade(new Grade(100, 150));
    assert(floatCmp(c1.score, 75, 0.05));

    auto course = new Course();
    assert(floatCmp(course.score, 100, 0.05));

    auto c2 = new Category(0.75);
    auto c3 = new Category(0.25);

    course.addCategory(c2);
    course.addCategory(c3);

    assert(floatCmp(course.totalWeight, 1, 0.05));
    assert(floatCmp(course.score, 100, 0.05));
    
    c2.addGrade(new Grade(100, 100));
    c3.addGrade(new Grade(20, 100));

    assert(floatCmp(course.score, 80, 0.05));

@
We test that the category weighting is working as it should;
we get 75 points from the first category, which has a category
score of 100\%, and 5 points from the second, which has a category
score of 20\%, giving a total grade of 80\% for the course.

<<unittests>>=
}

<<test-driver>>=
<<skeleton>>
<<unittests>>
